# Telperion

### What does **Telperion** do?

##### 1. Replace items in an expression via `getproperty`

```julia
using Telperion

struct A 
    thing
end

a = A("hello")

@withprops a collect(thing)
```

```
5-element Array{Char,1}:
 'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)
 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)
 'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)
 'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)
 'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)
```

##### 2. Parse statistical formulas into feature columns.

```julia
using DataFrames, StatsBase, Telperion

df = DataFrame(y=rand(100), a=1:100, b=randn(100), c=randn(100), d=rand(1:5, 100))

x, y = @xy df log.(y) ~ 1 + a + zscore(b) + abs.(sin.(c)) + dummy(d)

x
```

```
OrderedDict{String,Any} with 8 entries:
  "1"            => [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  "log.(a)"      => [0.0, 0.693147, 1.09861, 1.38629, 1.60944, 1.79176, 1.94591, 2.07944, 2.19722, 2.30259  …  4.51086, 4.52179, 4.5326, 4.54329, 4.55388, 4.56435, 4.5…
  "zscore(b)"    => [0.331412, 1.13535, 1.32111, -0.942869, -0.962877, 0.150559, 0.228082, -0.252694, 0.66791, 0.643581  …  0.669354, 0.727924, 1.35388, 1.87328, 0.694…
  "mean(b)"      => [-0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543, -0.0240543  …  -0.0240543, -0.0240543,…
  "dummy(d) [2]" => Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
  "dummy(d) [3]" => Bool[0, 0, 0, 0, 0, 0, 1, 1, 0, 0  …  0, 0, 0, 1, 0, 1, 0, 0, 0, 1]
  "dummy(d) [4]" => Bool[0, 0, 0, 1, 1, 0, 0, 0, 1, 0  …  0, 0, 0, 0, 0, 0, 1, 1, 0, 0]
  "dummy(d) [5]" => Bool[1, 1, 0, 0, 0, 0, 0, 0, 0, 0  …  0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
```

### Why does **Telperion** exist?

I wanted to try my own take on StatsModels where each term is generated by valid Julia code rather than a DSL.

Formula syntax is `y ~ term1 + term2 + term3`

- The response variables and predictors are separated with `~`.
- Terms are separated with `+`.
- Numbers are turned into vectors e.g. `1` --> `fill(1, size(df, 1))`

##### Benefits

- Simplicity (currently sitting at 64 LOC).
- Terms can be any Julia code that creates:
  - An `AbstractVector` or iterable of the correct length.
  - An `OrderedDict` of `AbstractVector`/iterables (for terms that create multiple columns)
- Works out of the box with many data structures.

```julia
using IndexedTables 

t = table((x=rand(10), y=rand(10)))

x, y = @xy rows(t) y ~ 1 + x
```

##### Limitations

- Any `Symbol` `x` in an expression will get replaced if `hasproperty(source, x)`.  E.g. you cannot have a field called `log` and also use the `Base.log` function.